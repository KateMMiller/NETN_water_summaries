---
output: 
  html_document:
    fig_caption: yes
    css: stylesheets/custom_styles.css
    anchor_sections: FALSE
    includes: 
      in_header: "header_manual.html" 
      after_body: "footer.html"
    self_contained: yes
params:
  park: ACAD # 4-letter park code
  from: 2006 # first year of data
  current: 2022 # current year of data
  nutrient: TRUE # T plots nutrients, but should be complete for season
  plottype: bands # plot bands or boxplot for nutrients
---
```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.pos = "h")
```

```{r libs, include = FALSE, results = 'hide'}
##------------------------------------------------------------------------------
## Load data and libraries
##------------------------------------------------------------------------------
library(NCRNWater)
library(dplyr)
library(tidyr)
library(purrr)
library(ggplot2)
library(plotly)
library(htmltools)
library(leaflet)
library(viridis)
library(kableExtra)
library(lubridate)
library(gridExtra) # for grid.arrange in fake_bands
library(ggpubr) # as_ggplot
library(knitr)
```

```{r import}
netnwd <- importNCRNWater(Dir = "../data", 
                          Data = "Water Data.csv", 
                          MetaData = "VizMetaData.csv")

# netnwd <- importNCRNWater(Dir = "./data",
#                          Data = "Water Data.csv",
#                          MetaData = "VizMetaData.csv")
```

```{r legend_cust, warning = F, message = F, include = F, echo = F, results = 'hide'}
source("fake_bands_legend_code.R") # creates legend with fake data 
#source("./rmd/fake_bands_legend_code.R") 
```

```{r globvars, message = F}
##------------------------------------------------------------------------------
## Global variables
##------------------------------------------------------------------------------
# Variables for cat asis code, which can't take params
# parkcode = "ACAD"
# current = 2022
# from = 2006
# to = 2021
# nutrient = TRUE
# plottype = 'bands'

# Variables for cat asis code, which can't take params
current = params$current
to = current - 1
parkcode = params$park
from = params$from
nutrient = params$nutrient
plottype = params$plottype

# Determine whether waterboxplot_function needs to be evaluated
boxplot_eval = ifelse(params$plottype != 'bands', TRUE, FALSE)

# Long park name
long_name = getParkInfo(netnwd, park = parkcode, info = "ParkLongName")

# Load water data for given park and add variables needed for plotting
wdata <- getWData(netnwd, parkcode = parkcode, output = 'dataframe')
wdata <- wdata |> mutate(year = year(Date),
                       month = month(Date, label = TRUE, abbr = TRUE),
                       month_num = as.numeric(month))

if(nrow(wdata |> filter(year == current)) == 0){
  stop(paste0("There are no data available for ", parkcode, " in specified year ", current))
}

# List of sites
site_list_all <- sort(unique(wdata$Site))
site_curr <- sort(unique(wdata$Site[wdata$year == current]))

# Set up site_list so only includes sites sampled in current year
site_list <- site_list_all[site_list_all %in% site_curr]

# Create site key for sitecode and type
site_key <- purrr::map_dfr(site_list,
  ~data.frame(Site = getSiteInfo(netnwd, parkcode = parkcode, 
                                sitecode = ., info = "SiteCode"),
             SiteName = getSiteInfo(netnwd, parkcode = parkcode, 
                                    sitecode = ., info = "SiteName"),
             SiteType =  getSiteInfo(netnwd, parkcode = parkcode, 
                                     sitecode = ., info = "type")))

# Import lower and upper assessment values and join with wdat
charinfo <- data.frame(
  Site = getCharInfo(netnwd, parkcode = parkcode, sitecode = site_key$Site,
                     info = "SiteCode"),
  CharName = getCharInfo(netnwd, parkcode = parkcode, sitecode = site_key$Site, 
                         info = "CharName"),
  DisplayName = getCharInfo(netnwd, parkcode = parkcode, sitecode = site_key$Site, 
                         info = "DisplayName"),
  unit = getCharInfo(netnwd, parkcode = parkcode, sitecode = site_key$Site,
                     info = "Units"),
  type = getCharInfo(netnwd, parkcode = parkcode, sitecode = site_key$Site,
                     info = "type"), 
  param_name = getCharInfo(netnwd, parkcode = parkcode, sitecode = site_key$Site,
                           info = "CategoryDisplay"),
  LowerPoint = getCharInfo(netnwd, parkcode = parkcode, sitecode = site_key$Site, 
                           info = "LowerPoint"),
  UpperPoint = getCharInfo(netnwd, parkcode = parkcode, sitecode = site_key$Site, 
                           info = "UpperPoint"))

# Combine WQ thresholds with water data
wdata2 <- left_join(wdata, charinfo, by = c("Site", "Characteristic" = "CharName"), 
                  multiple = "all", relationship = 'many-to-many') |> 
          mutate(pcolor = 
           ifelse(!is.na(UpperPoint) & year == current & ValueCen > UpperPoint, 
                  "Poor WQ value",
           ifelse(!is.na(LowerPoint) & year == current & ValueCen < LowerPoint, 
                  "Poor WQ value", "Current value")),
           yname = ifelse(param_name != 'pH', paste0(param_name, " (", unit, ")"), "pH"))

# Add site names to water data
wdata_full <- left_join(wdata2 |> select(-type), site_key, by = "Site") |> arrange(Date)
wdata_curr <- wdata_full |> filter(year == current)
wdata_hist <- wdata_full |> filter(year < current)

# Turn on comp tab if park has more than one site
show_comp <- ifelse(length(site_list) > 1, TRUE, FALSE)
show_comp_n <- ifelse(show_comp == TRUE & nutrient == TRUE, TRUE, FALSE)

site_list_lake <- site_key |> filter(SiteType == "Lake") |> filter(Site %in% site_curr)
site_list_stream <- site_key |> filter(SiteType == "Stream") |> filter(Site %in% site_curr)
```

```{r waterboxplot, eval = boxplot_eval}
source('waterboxplot_function.R')
```


```{r lake_comp_setup, echo = F, warning = F, message = F, eval = show_comp}
##------------------------------------------------------------------------------
## LAKES - Physical site comp setup
##------------------------------------------------------------------------------
# List of physical lake parameters (excludes discharge)
char_list_lake_p <- sort(unique(wdata_full$Characteristic[wdata_full$Category == 'physical' & 
                                                          wdata_full$SiteType == "Lake"]))
#table(wdata_full$SiteType, wdata_full$Characteristic, wdata_full$Category)

# Turn off all legends except last in list to remove legend duplicates from subplot
legend_list_lake_p <- c(rep("none", length(char_list_lake_p)-1), "bottom")

# Create list of plots comparing physical parameters across all lakes in park
comp_plots_lake_p <- purrr::map2(char_list_lake_p, legend_list_lake_p,
                         ~watersite_comps(netnwd, year = current, 
                                     parkcode = "ACAD", 
                                     sitecode = site_list_lake$Site,
                                     charname = .x,
                                     legend = .y) + 
                           labs(color = NULL, fill = NULL, shape = NULL, linetype = NULL)) %>%
              set_names(char_list_lake_p) #name plots to refer to them by char name

heights_lake_p <- c(0.5, 0.5)

# Use plot list to create matrix of plots (plotly subplot)
comp_plots_lake_p_final <- subplot(comp_plots_lake_p[1:length(comp_plots_lake_p)],
                         titleY = TRUE, titleX = FALSE, margin = 0.08,
                         #create 3 rows if more than 4 plots, otherwise 2 rows
                         nrows = ifelse(length(comp_plots_lake_p)> 4, 3, 2),
                         #set height of each row (default makes middle row shorter)
                         heights = heights_lake_p) %>% 
  # turn off subplot legend
  style(showlegend = FALSE) %>% 
  # manually set width and height of subplot
  layout(autosize = FALSE)#, width = 900, height = 650)

num_sites_lake_p <- c(1:length(site_list_lake))

# Turn on legend elements 
for (i in 1:length(num_sites_lake_p)){
  comp_plots_lake_p_final$x$data[[i]]$showlegend <- TRUE #site (line/markers)
  comp_plots_lake_p_final$x$data[[length(comp_plots_lake_p_final$x$data)]]$showlegend <- TRUE #threshold line
  comp_plots_lake_p_final$x$data[[length(comp_plots_lake_p_final$x$data)]]$name <- "WQ Threshold" #set name
}

# Move legend down slightly and make it horizontal
comp_plots_lake_p_final <- comp_plots_lake_p_final %>% layout(legend = list(x = 0, y = -0.15, orientation = "h"))
```

```{r lake_comp_setup_n, eval = show_comp_n, echo = F, warning = F, message = F, error = TRUE}
##------------------------------------------------------------------------------
## LAKES - Nutrients site comp setup
##------------------------------------------------------------------------------
# List of nutrient parameters to include in site comparison
char_list_lake_n <- c("TN_mgL", "TP_ugL")

# Turn off all legends except last in list to remove legend duplicates from subplot
legend_list_lake_n <- c(rep("none", length(char_list_lake_n)-1), "bottom")

# Create list of plots comparing physical parameters across all sites in park
comp_plots_lake_n <- purrr::map2(char_list_lake_n, legend_list_lake_n,
                         ~watersite_comps(netnwd, 
                                          year = current, 
                                          parkcode = parkcode, 
                                          sitecode = site_list_lake$Site,
                                          charname = .x,
                                          legend = .y)) %>%
              set_names(char_list_lake_n) #name plots to refer to them by char name

# Use plot list to create matrix of plots (plotly subplot)

#+++++++++++++ ENDED HERE +++++++++++++++++
# Problems arise when some sites don't have TN or TP. Have to
# figure that out first, rather than just assume each site has TN and/or TP
#++++++++++++++++++++++++++++++++++++++++++


comp_plots_lake_n_final <- subplot(comp_plots_lake_n[1:length(comp_plots_lake_n)],
                         titleY = TRUE, titleX = FALSE, margin = 0.05, nrows = 1) %>% 
  # turn off subplot legend, manually set height and width of subplot
  style(showlegend = FALSE) %>% layout(autosize = FALSE)#, width = 900, height = 300)

num_sites_lake_n <- c(1:length(site_list_lake))

# Turn on legend elements 
for (i in 1:length(num_sites_lake_n)){
  comp_plots_lake_n_final$x$data[[i]]$showlegend <- TRUE #site (line/markers)
  #comp_plots_lake_n_final$x$data[[length(comp_plots_lake_n_final$x$data)]]$showlegend <- TRUE #threshold line
  #comp_plots_lake_n_final$x$data[[length(comp_plots_lake_n_final$x$data)]]$name <- "WQ Threshold" #set name
}

# Move legend down slightly and make it horizontal
comp_plots_lake_n_final <- comp_plots_lake_n_final %>% layout(legend = list(x = 0, y = -0.12, orientation = "h"))

```

# `r long_name` {.tabset .tabset-fade .tabset-pills}

```{r lake_p_site_comp, results = 'asis', include = show_comp}
##------------------------------------------------------------------------------
## LAKES - Physical site comp plots                          
##------------------------------------------------------------------------------
# Create lake tab
cat("## ", "Lakes","{.tabset}", "\n")

# Lake comparison tab
cat("### ", "All Lakes","{.tabset}", "\n")

# Create a physical parameter subtab if also reporting nutrients
if(params$nutrient==TRUE) {cat("#### ", "Field Measurements", "\n")}

# Title of tab
cat("<h2>Monthly Water Quality Measurements", paste0("(", parkcode, " ", current, ")"),"</h2>")

# Figure caption
fig_cap_comp_p <- htmltools::withTags(body(
                          'The plots below compare monthly
                          measurements across all', long_name, 'sites during the',
                          current, 'field season. Only water quality parameters
                          that are measured at multiple sites are included. Water
                          quality thresholds are derived from state surface water 
                          quality standards. Parameter abbreviations and additional 
                          information are defined in "About the Data".'))

cat(as.character(fig_cap_comp_p))
```

```{r p_site_comp_plots, results = 'show', out.height = "90%", eval = show_comp}
comp_plots_lake_p_final

# NOTE: The space directly below between p_site_comp and n_site_comp is necessary 
# for tabset to work in a combined report (physical and nutrients) 
# Adding cat("\n") does not work
```

```{r lake_n_site_comp, results = 'asis', eval = show_comp_n, include = show_comp_n}
##------------------------------------------------------------------------------
## LAKES - Nutrient site comp plots                            
##------------------------------------------------------------------------------
# Create nutrient subtab if reporting nutrients
if(params$nutrient==TRUE) {cat("#### ", "Lab Chemistry", "\n")}

# Subtab title
if(params$nutrient==TRUE) {cat("<h2>Monthly Water Quality Measurements", paste0("(", parkcode, " ", current, ")"),"</h2>")}

# Figure caption
fig_cap_comp_n <- htmltools::withTags(body(
                          'The plots below compare monthly
                          measurements across all', long_name, 'sites during the',
                          current, 'field season. Only water quality parameters
                          that are measured at multiple sites are included. Water 
                          quality thresholds represent the lower 5th percentile 
                          of reference waters in the region, and separate moderate 
                          from most disturbed sites. Parameter 
                          abbreviations and additional information are defined in
                          "About the Data".'))

# Figure caption
if(params$nutrient==TRUE) {cat(as.character(fig_cap_comp_n))}
```
```{r n_site_comp_plots, results = 'show', out.height = "90%", eval = show_comp_n, include = show_comp_n}
if(params$nutrient==TRUE) {comp_plots_lake_n_final}
```

```{r lake_site_tab_setup, warning = F, message = F}
##------------------------------------------------------------------------------
## LAKES - Physical site tab setup                          
##------------------------------------------------------------------------------
# Create dataframe of physical parameters
char_df_p <- map(site_list, ~getCharInfo(netnwd, parkcode = parkcode, sitecode = ., 
                             category = params$cat, info = "CharName")) %>%  
                 set_names(site_list) %>% unlist() %>% as.data.frame() 
                 #unlisting matches a site to each param

# Reorganize dataframe                 
char_df_p$site_code <- substr(row.names(char_df_p), 1, 14) #select the site code
colnames(char_df_p) <- c("char_name", "site_code") #rename columns
rownames(char_df_p) <- c() #remove row names

# Add site type to dataframe
char_df_p <- char_df_p[c("site_code", "char_name")] %>% #rearrange column order
  left_join(., site_key, by = c("site_code"="Site")) #add site type to dataframe
  
# Subset dataframe by lake sites
char_df_lake_p <- char_df_p %>% filter(SiteType=="Lake")

# Iterate on dataframe to create waterbands plots
#2022 drop 1:4 NETN_ACAD_BOWL
#2022 drop 29:32 NETN_ACAD_SAMP
rng = c(5:28, 33:48)
plot_list_lake_p <- 
  map2(char_df_lake_p$site_code[rng], char_df_lake_p$char_name[rng], 
                    ~waterbands(netnwd, parkcode = parkcode, sitecode = .x, 
                              charname = .y, year_current = current,
                              year_historic = from, legend = "bottom")) %>% 
                    set_names(char_df_lake_p$site_code[rng])
```

```{r lake_site_tab_setup_n, warning = F, message = F, eval = show_comp_n, include = show_comp_n}
##------------------------------------------------------------------------------
## LAKES - Nutrient site tab setup                          
##------------------------------------------------------------------------------
# Create dataframe of nutrient parameters
char_df_lake_n <- map(site_list, ~getCharInfo(netnwd, parkcode = parkcode, sitecode = ., 
                             category = "nutrients", info = "CharName")) %>%  
                  set_names(site_list) %>% unlist() %>% as.data.frame() 
                  #unlisting matches a site to each param

# Reorganize dataframe
char_df_lake_n$site_code <- substr(row.names(char_df_lake_n), 1, 14) #select the site code
colnames(char_df_lake_n) <- c("charname", "sitecode") #rename columns
rownames(char_df_lake_n) <- c() #remove row names

# Select target nutrients by site
char_df_lake_n <- char_df_lake_n[c("sitecode", "charname")] %>% 
  left_join(., site_key, by = c("sitecode"="Site")) %>% #add site type to dataframe
  filter((SiteType=="Lake" & charname %in% nutrients_lake))# | (SiteType=="Stream" & charname %in% nutrients_stream))

# Iterate on dataframe to create nutrient plots
plot_list_lake_n <- map2(char_df_lake_n$sitecode, char_df_lake_n$charname, 
                    ~waterboxplot(sitecode=.x, charname=.y)) %>% 
                    set_names(char_df_lake_n$sitecode)

```

```{r lake_site_tabs, warning = F, message = F, results='asis'}
##------------------------------------------------------------------------------
## LAKES - Site tabs                       
##------------------------------------------------------------------------------
# Loop on list of sites to create tabs for each site and fill them with plots
# 2022 drop BOWL and SAMP
for(i in #seq_along(site_list_lake[
  c(2:7, 9:12)
#  ])
  ){
  #i = 2
  site <- site_list_lake[i] # change back to i
  site_name <- getSiteInfo(netnwd, parkcode = parkcode, sitecode = site, 
                          info = "SiteName")
  
  num_plots_p <- length(plot_list_lake_p[names(plot_list_lake_p) == site])
  num_plots_n <- ifelse(exists("plot_list_lake_n") & params$nutrient == TRUE, length(plot_list_lake_n[names(plot_list_lake_n) == site]), 0)
  
  plot_title <- htmltools::withTags(h2('Historic', paste0('(',from, '–', to,')'),
                                                'vs. Current', paste0('(',current,')'), 'Measurements'))
  # Physical parameters (waterbands) figure caption                                               
  fig_cap_p <- htmltools::withTags(body('The plots below show historic ranges for', site_name, 
                                        'based on the range of measurements collected from',
                                        from, 'to', to, 'for each month. The outermost band represents the
                                        historic maximum and minimum value collected for each month.
                                        The second inner band represents the 95% range of historic values
                                        by month. The innermost band represents the 50% range of historic
                                        values by month. The points represent the most 
                                        recent measurements collected in', current, 'by month. 
                                        Water quality thresholds are derived from state surface water 
                                        quality standards.  Parameter abbreviations and additional 
                                        information are defined in "About the Data".'))
  # Nutrient parameters (boxplot) figure caption
  fig_cap_n <- htmltools::withTags(body('The boxplots below show historic ranges for', site_name, 
                                        'based on the range of measurements collected from', from, 'to', to, 
                                        'for each month. The lower and upper box boundaries represent the 
                                        25th (Q1) and 75th (Q3) percentiles, respectively, and together show 
                                        the interquartile range (IQR). The line inside the box is the 50th 
                                        percentile (median). Asterisks outside of the lower and 
                                        upper fence range (Q1 - 1.5*IQR, Q3 + 1.5*IQR) are considered 
                                        outliers. The points represent the most recent 
                                        measurements collected in', current, 'by month. Water 
                                        quality thresholds represent the lower 5th percentile 
                                        of reference waters in the region, and separate moderate 
                                        from most disturbed sites. Parameter abbreviations and additional 
                                        information are defined in "About the Data".'))
  
  # Fig heights need to be separate params because the tab template doesn't allow duplicates
  fig_height_p <- ifelse(num_plots_p > 4, 6.5, 4.5)
  fig_height_n <- ifelse(num_plots_n > 4, 6.5, 4.5)
  fig_width <- 9.3
  
  # Physical subplot
  subplots_p <- subplot(plot_list_lake_p[names(plot_list_lake_p) == site][1:num_plots_p],
                      titleY = TRUE, titleX = FALSE, margin = 0.05,
                      nrows = ifelse(num_plots_p > 4, 3, 2),
                      heights = if(num_plots_p > 4) {c(0.3,0.35,0.3)}) %>% 
             layout(legend = list(x = 0, y = ifelse(num_plots_p > 4, -0.05, -0.08),
                                  orientation = "h"))
  
  # Nutrient subplot
  subplots_n <- if(params$nutrient == TRUE & exists("plot_list_lake_n")){
             subplot(plot_list_lake_n[names(plot_list_lake_n) == site][1:num_plots_n],
                      titleY = TRUE, titleX = FALSE, margin = 0.05,
                      nrows = ifelse(num_plots_n>4, 3, 2),
                      which_layout = 1) %>% 
             layout(legend = list(x = 0, y = ifelse(num_plots_n>4, -0.05, -0.08),
                                  orientation = "h"))}

##------------------------------------------------------------------------------
## Legend - physical                          
##------------------------------------------------------------------------------
  # Logical way to find and turn on poor water quality and WQ thresholds
  # First turn them all off
  for (i in seq(1:length(subplots_p$x$data))) {
    subplots_p$x$data[[i]]$showlegend <- FALSE
  }
  
  # Find the first time the poor water quality point is used- returns the index number
  # +++++ 20221109 FAILS HERE ++++++
  # find_pwq <- data.frame(pwq = lapply(seq_along(subplots_p$x$data), 
  #   function(i){
  #     if(subplots_p$x$data[[i]]$name == "orange"){paste0(i)
  #       } else{NA}}) %>% 
  #     unlist()) %>% na.omit() %>% slice(1) %>% as.numeric()
  # 
  # Find the first time the water quality threshold is used- returns the index number
  # find_wqt <- data.frame(wqt = lapply(seq_along(subplots_p$x$data),
  #   function(i){
  #     if(!is.null(subplots_p$x$data[[i]]$line$dash)){
  #     if(subplots_p$x$data[[i]]$line$dash == "dash"){
  #       paste0(i)
  #       } else{NA}}
  #       else{NA}
  #     } ) %>% unlist()) %>%
  #     na.omit() %>% slice(1) %>% as.numeric()
  
  # Turn on the legends that never change
  subplots_p$x$data[[2]]$showlegend <- TRUE
  subplots_p$x$data[[2]]$name = "Historic range"
  subplots_p$x$data[[5]]$showlegend <- TRUE
  subplots_p$x$data[[5]]$name = "Historic 95% range"
  subplots_p$x$data[[8]]$showlegend <- TRUE
  subplots_p$x$data[[8]]$name = "Historic 50% range"
  subplots_p$x$data[[11]]$showlegend <- TRUE
  subplots_p$x$data[[11]]$name = "Historic median"
  subplots_p$x$data[[12]]$showlegend <- TRUE
  subplots_p$x$data[[12]]$name = "Current value"
  
  # Turn on the poor water quality and thresholds if they existed
  # +++++++ 20221109 FAILS HERE ++++++
  # if(!is.na(find_pwq)){
  #   subplots_p$x$data[[find_pwq]]$showlegend <- TRUE
  #   subplots_p$x$data[[find_pwq]]$name <- "Poor WQ value"}
  # 
  # if(!is.na(find_wqt)){
  #   subplots_p$x$data[[find_wqt]]$showlegend <- TRUE
  #   subplots_p$x$data[[find_wqt]]$name <- "WQ threshold"}
  # 
##------------------------------------------------------------------------------
## Legend - nutrients                          
##------------------------------------------------------------------------------
  # Logical way to find and turn on poor water quality and WQ thresholds
  # First turn them all off
  if(params$nutrient == TRUE & !is.null(subplots_n)){
  for (i in seq(1:length(subplots_n$x$data))) {
    subplots_n$x$data[[i]]$showlegend <- FALSE
  }
  
  # Find the first time the historic range is used- returns the index number
  find_hstr <- data.frame(hstr = lapply(seq_along(subplots_n$x$data),
    function(i){
      if(subplots_n$x$data[[i]]$name == "Historic range"){
        paste0(i)
        } else{NA}
      } ) %>% unlist()) %>%
      na.omit() %>% slice(1) %>% as.numeric()
  
   # Find the first time the current value is used- returns the index number
  find_ctv <- data.frame(ctv = lapply(seq_along(subplots_n$x$data),
    function(i){
      # Check that the point has a y value (exists on the plot)
      y_check <- grepl("y",subplots_n$x$data[[i]]$y, fixed=TRUE) %>% unique()
      if(subplots_n$x$data[[i]]$name == "Current value" & y_check==FALSE){paste0(i)
        } else{NA}
      } ) %>% unlist()) %>%
      na.omit() %>% slice(1) %>% as.numeric()
  
  # Find the first time the poor water quality point is used- returns the index number
  find_pwq <- data.frame(pwq = lapply(seq_along(subplots_n$x$data),
    function(i){
      # Check that the point has a y value (exists on the plot)
      y_check <- grepl("y",subplots_n$x$data[[i]]$y, fixed=TRUE) %>% unique()
      if(subplots_n$x$data[[i]]$name == "Poor WQ value" & y_check==FALSE){paste0(i)
        } else{NA}}) %>%
      unlist()) %>% na.omit() %>% slice(1) %>% as.numeric()

  # Find the first time the water quality threshold is used- returns the index number
  find_wqt <- data.frame(wqt = lapply(seq_along(subplots_n$x$data),
    function(i){
      if(subplots_n$x$data[[i]]$name == "WQ threshold"){
        paste0(i)
        } else{NA}
      } ) %>% unlist()) %>%
      na.omit() %>% slice(1) %>% as.numeric()

  # Turn on the historic, current, poor WQ, and threshold legends if they exist
  if(!is.na(find_hstr)){
    subplots_n$x$data[[find_hstr]]$showlegend <- TRUE
    }
  
  if(!is.na(find_ctv)){
    subplots_n$x$data[[find_ctv]]$showlegend <- TRUE
    }
  
  if(!is.na(find_pwq)){
    subplots_n$x$data[[find_pwq]]$showlegend <- TRUE
    }

  if(!is.na(find_wqt)){
    subplots_n$x$data[[find_wqt]]$showlegend <- TRUE
    }
  } # end of if(params$nutrient == T & !is.null(subplots_n))
##------------------------------------------------------------------------------
## Knit tabs                          
##------------------------------------------------------------------------------
  
  # Create unique chunk labels to use in the tab templates
  site_n <- paste0(site, '_n')
  site_p <- paste0(site, '_p')
  
  # Create tab chunk templates
  # Variables within {{}} are replaced by their value when the report is knit
  
  # if NOT reporting nutrients, use physical parameter template
    if(params$nutrient == FALSE) {
    template <- paste0(
      "### {{site_name}}\n", #create tab with site name
      #create chunk and set chunk options (height, width, echo)
      "```{r {{site_p}}, fig.height=",fig_height_p, ", fig.width=", fig_width,", echo = FALSE}\n",
      "plot_title\n", #title of tab
      "\n",
      "fig_cap_p\n", #caption
      "subplots_p\n", #physical subplots
      "```\n", #close chunk
      "\n"
  )
    # if reporting nutrients, create physical and nutrient subtabs 
    } else {template <- paste0(
      "### {{site_name}}{.tabset}\n", #create tab with site name
      "#### Field Measurements\n", #physical subtab
      "```{r {{site_p}}, fig.height=",fig_height_p, ", fig.width=", fig_width,", echo = FALSE}\n",
      "plot_title\n", #title of tab
      "\n",
      "fig_cap_p\n", #caption
      "subplots_p\n", #physical subplots
      "```\n",
      "\n", #this break is necessary for the subtabs to knit correctly
      "#### Lab Chemistry\n", #nutrient subtab
      "```{r {{site_n}}, fig.height=",fig_height_n, ", fig.width=", fig_width,", echo = FALSE}\n",
      "plot_title\n", #title of tab
      "\n",
      "fig_cap_n\n", #caption
      "subplots_n\n", #nutrient subplots
      "```\n",
      "\n"
  )
}
  
  # Expand expressions within {{ }}
  tab <- knitr::knit_expand(text = template)
  
  # Knit results
  cat(knitr::knit(text = unlist(tab), quiet = TRUE))
  
}

```

```{r stream_comp_setup, echo = F, warning = F, message = F, eval = show_comp}
##------------------------------------------------------------------------------
## STREAMS - Physical site comp setup
##------------------------------------------------------------------------------
# List of physical stream parameters (includes discharge)
char_list_stream_p <- getCharInfo(netnwd, parkcode = parkcode, category = params$cat, 
                           info = "CharName") %>%
               unique() #%>% #remove duplicates
               #.[!.=="Discharge_cfs"] #remove discharge

# Turn off all legends except last in list to remove legend duplicates from subplot
legend_list_stream_p <- c(rep("none", length(char_list_stream_p)-1), "bottom")

# Create list of plots comparing physical parameters across all lakes in park
comp_plots_stream_p <- purrr::map2(char_list_stream_p, legend_list_stream_p,
                            ~watersite_comps(netnwd, year = current, 
                                             parkcode = parkcode, 
                                             sitecode = site_list_stream,
                                             charname = .x,
                                             legend = .y)) %>%
  set_names(char_list_stream_p) #name plots to refer to them by char name

heights_stream_p <- c(0.3,0.35,0.3)

# Use plot list to create matrix of plots (plotly subplot)
comp_plots_stream_p_final <- subplot(comp_plots_stream_p[1:length(comp_plots_stream_p)],
                                titleY = TRUE, titleX = FALSE, margin = 0.05,
                                #create 3 rows if more than 4 plots, otherwise 2 rows
                                nrows = ifelse(length(comp_plots_stream_p)> 4, 3, 2),
                                #set height of each row (default makes middle row shorter)
                                heights = heights_stream_p) %>% 
                            # turn off subplot legend
                            style(showlegend = FALSE) %>% 
                            # manually set width and height of subplot
                            layout(autosize = FALSE, width = 900, height = 650)

num_sites_stream_p <- c(1:length(site_list_stream))

# Turn on legend elements 
for (i in 1:length(num_sites_stream_p)){
  comp_plots_stream_p_final$x$data[[i]]$showlegend <- TRUE #site (line/markers)
  #comp_plots_stream_p_final$x$data[[length(comp_plots_stream_p_final$x$data)]]$showlegend <- TRUE #threshold line
  #comp_plots_stream_p_final$x$data[[length(comp_plots_stream_p_final$x$data)]]$name <- "WQ Threshold" #set name
}

# Move legend down slightly and make it horizontal
comp_plots_stream_p_final <- comp_plots_stream_p_final %>% layout(legend = list(x = 0, y = -0.05, orientation = "h"))
```
```{r stream_comp_setup_n, echo = F, warning = F, message = F, eval = show_comp_n, error = TRUE}
##------------------------------------------------------------------------------
## STREAMS - Nutrients site comp setup
##------------------------------------------------------------------------------
# List of nutrient parameters to include in site comparison
char_list_stream_n <- c("TN_mgL", "TP_ugL")

# Turn off all legends except last in list to remove legend duplicates from subplot
legend_list_stream_n <- c(rep("none", length(char_list_stream_n)-1), "bottom")

# Create list of plots comparing physical parameters across all sites in park
comp_plots_stream_n <- purrr::map2(char_list_stream_n, legend_list_stream_n,
                            ~watersite_comps(netnwd, 
                                             year = current, 
                                             parkcode = parkcode, 
                                             sitecode = site_list_stream,
                                             charname = .x,
                                             legend = .y)) %>%
  set_names(char_list_stream_n) #name plots to refer to them by char name

# Use plot list to create matrix of plots (plotly subplot)
comp_plots_stream_n_final <- subplot(comp_plots_stream_n[1:length(comp_plots_stream_n)],
                              titleY = TRUE, titleX = FALSE, margin = 0.05, nrows = 1) %>% 
  # turn off subplot legend, manually set height and width of subplot
  style(showlegend = FALSE) %>% layout(autosize = FALSE, width = 900, height = 300)

num_sites_stream_n <- c(1:length(site_list_stream))

# Turn on legend elements 
for (i in 1:length(num_sites_stream_n)){
  comp_plots_stream_n_final$x$data[[i]]$showlegend <- TRUE #site (line/markers)
  #comp_plots_stream_n_final$x$data[[length(comp_plots_stream_n_final$x$data)]]$showlegend <- TRUE #threshold line
  #comp_plots_stream_n_final$x$data[[length(comp_plots_stream_n_final$x$data)]]$name <- "WQ Threshold" #set name
}

# Move legend down slightly and make it horizontal
comp_plots_stream_n_final <- comp_plots_stream_n_final %>% layout(legend = list(x = 0, y = -0.12, orientation = "h"))
```

```{r stream_p_site_comp, results = 'asis', include = show_comp}
##------------------------------------------------------------------------------
## STREAMS - Physical site comp plots                            
##------------------------------------------------------------------------------
# Create lake tab
cat("## ", "Streams","{.tabset}", "\n")

# Lake comparison tab
cat("### ", "All Streams","{.tabset}", "\n")

# Create a physical parameter subtab if also reporting nutrients
if(params$nutrient==TRUE) {cat("#### ", "Field Measurements", "\n")}

# Title of tab
cat("<h2>Monthly Water Quality Measurements", paste0("(", parkcode, " ", current, ")"),"</h2>")

# Figure caption 
cat(as.character(fig_cap_comp_p))
```
```{r stream_p_site_comp_plots, results = 'show', out.height = "90%", eval = show_comp}
comp_plots_stream_p_final

# NOTE: The space directly below between p_site_comp and n_site_comp is necessary 
# for tabset to work in a combined report (physical and nutrients) 
# Adding cat("\n") does not work
```

```{r stream_n_site_comp, results = 'asis', eval = show_comp_n, error = TRUE}
##------------------------------------------------------------------------------
## STREAMS - Nutrient site comp plots                            
##------------------------------------------------------------------------------
# Create nutrient subtab if reporting nutrients
if(params$nutrient==TRUE) {cat("#### ", "Lab Chemistry", "\n")}

# Subtab title
if(params$nutrient==TRUE) {cat("<h2>Monthly Water Quality Measurements", paste0("(", parkcode, " ", current, ")"),"</h2>")}

# Figure caption
if(params$nutrient==TRUE) {cat(as.character(fig_cap_comp_n))}
```
```{r stream_n_site_comp_plots, results = 'show', out.height = "90%", eval = show_comp}
if(params$nutrient==TRUE) {comp_plots_stream_n_final}
```

```{r stream_site_tab_setup, warning = F, message = F}
##------------------------------------------------------------------------------
## STREAMS - Physical site tab setup
##------------------------------------------------------------------------------
# # Create dataframe of physical parameters
# char_df_stream_p <- map(site_list, ~getCharInfo(netnwd, parkcode = parkcode, sitecode = .,
#                              category = params$cat, info = "CharName")) %>%
#                  set_names(site_list) %>% unlist() %>% as.data.frame()
#                  #unlisting matches a site to each param
# 
# # Reorganize dataframe
# char_df_stream_p$site_code <- substr(row.names(char_df_stream_p), 1, 14) #select the site code
# colnames(char_df_stream_p) <- c("char_name", "site_code") #rename columns
# rownames(char_df_stream_p) <- c() #remove row names
# char_df_stream_p <- char_df_stream_p[c("site_code", "char_name")] #rearrange column order

# Filter physical parameter dataframe (defined in lake tab setup) by stream
char_df_stream_p <- char_df_p %>% filter(SiteType=="Stream")

# Iterate on dataframe to create waterbands plots
plot_list_stream_p <- map2(char_df_stream_p$site_code, char_df_stream_p$char_name,
                  ~waterbands(netnwd, parkcode = parkcode, sitecode = .x,
                              charname = .y, year_current = current,
                              year_historic = from, legend = "bottom")) %>%
             set_names(char_df_stream_p$site_code)
```

```{r stream_site_tab_setup_n, echo = F, warning = F, message = F, eval = show_comp_n, error = TRUE}
##------------------------------------------------------------------------------
## STREAMS - Nutrient site tab setup
##------------------------------------------------------------------------------
# Create dataframe of nutrient parameters
char_df_stream_n <- map(site_list, ~getCharInfo(netnwd, parkcode = parkcode, sitecode = .,
                             category = "nutrients", info = "CharName")) %>%
                 set_names(site_list) %>% unlist() %>% as.data.frame()
                 #unlisting matches a site to each param

# Reorganize dataframe
char_df_stream_n$site_code <- substr(row.names(char_df_stream_n), 1, 14) #select the site code
colnames(char_df_stream_n) <- c("charname", "sitecode") #rename columns
rownames(char_df_stream_n) <- c() #remove row names

# Select target nutrients by site
char_df_stream_n <- char_df_stream_n[c("sitecode", "charname")] %>%
  left_join(., site_key, by = c("sitecode"="Site")) %>% #add site type to dataframe
  filter((SiteType=="Stream" & charname %in% nutrients_stream))

# Iterate on dataframe to create nutrient plots
plot_list_stream_n <- map2(char_df_stream_n$sitecode, char_df_stream_n$charname,
                      ~waterboxplot(sitecode=.x, charname=.y)) %>%
                      set_names(char_df_stream_n$sitecode)

# Look for NULL plots in stream plot list
null_check <- sapply(plot_list_stream_n[names(plot_list_stream_n)], is.null) %>%
  # remove NULL plots (those that return TRUE for is.null)
  .[. == FALSE] %>%
  # get the site names 
  names() %>% 
  # create unique list of sites that have current year data
  unique()

```

```{r stream_site_tabs, warning = F, message = F, results='asis'}
##------------------------------------------------------------------------------
## STREAMS - Site tabs                        
##------------------------------------------------------------------------------
# Loop on list of sites to create tabs for each site and fill them with plots
for(i in seq_along(site_list_stream)){
  site <- site_list_stream[i] # change back to i
  site_name <- getSiteInfo(netnwd, parkcode = parkcode, sitecode = site, 
                          info = "SiteName")
  
  num_plots_p <- length(plot_list_stream_p[names(plot_list_stream_p) == site])
  num_plots_n <- ifelse(params$nutrient == TRUE & exists("plot_list_stream_n"), 
                        length(plot_list_stream_n[names(plot_list_stream_n) == site]), 0)
  
  plot_title <- htmltools::withTags(h2('Historic', paste0('(',from, '–', to,')'),
                                                'vs. Current', paste0('(',current,')'), 'Measurements'))
  # Physical parameters (waterbands) figure caption                                               
  fig_cap_p <- htmltools::withTags(body('The plots below show historic ranges for', site_name, 
                                        'based on the range of measurements collected from',
                                        from, 'to', to, 'for each month. The outermost band represents the
                                        historic maximum and minimum value collected for each month.
                                        The second inner band represents the 95% range of historic values
                                        by month. The innermost band represents the 50% range of historic
                                        values by month. The points represent the most 
                                        recent measurements collected in', current, 'by month. 
                                        Water quality thresholds are derived from state surface water 
                                        quality standards.  Parameter abbreviations and additional 
                                        information are defined in "About the Data".'))
  # Nutrient parameters (boxplot) figure caption
  fig_cap_n <- htmltools::withTags(body('The boxplots below show historic ranges for', site_name, 
                                        'based on the range of measurements collected from', from, 'to', to, 
                                        'for each month. The lower and upper box boundaries represent the 
                                        25th (Q1) and 75th (Q3) percentiles, respectively, and together show 
                                        the interquartile range (IQR). The line inside the box is the 50th 
                                        percentile (median). Asterisks outside of the lower and 
                                        upper fence range (Q1 - 1.5*IQR, Q3 + 1.5*IQR) are considered 
                                        outliers. The points represent the most recent 
                                        measurements collected in', current, 'by month. Water 
                                        quality thresholds represent the lower 5th percentile 
                                        of reference waters in the region, and separate moderate 
                                        from most disturbed sites.
                                        Parameter abbreviations and additional information are defined in
                                        "About the Data".'))
  
  # Fig heights need to be separate params because the tab template doesn't allow duplicates
  fig_height_p <- ifelse(num_plots_p > 4, 6.5, 4.5)
  fig_height_n <- ifelse(num_plots_n > 4, 6.5, 4.5)
  fig_width <- 9.3
  
  # Physical subplot
  subplots_p <- subplot(plot_list_stream_p[names(plot_list_stream_p) == site][1:num_plots_p],
                      titleY = TRUE, titleX = FALSE, margin = 0.05,
                      nrows = ifelse(num_plots_p>4, 3, 2),
                      heights = if(num_plots_p>4) {c(0.3,0.35,0.3)}) %>% 
             layout(legend = list(x = 0, y = ifelse(num_plots_p>4, -0.05, -0.08),
                                  orientation = "h"))
  
  # Nutrient subplot
  subplots_n <- if(params$nutrient == TRUE & exists("plot_list_stream_n")){ 
                 subplot(plot_list_stream_n[names(plot_list_stream_n) == site][1:num_plots_n],
                         titleY = TRUE, titleX = FALSE, margin = 0.05,
                         nrows = ifelse(num_plots_n>4, 3, 2),
                         which_layout = 1) %>% 
                layout(legend = list(x = 0, y = ifelse(num_plots_n>4, -0.05, -0.08),
                                     orientation = "h"))}

  # Aunt Betty Inlet legend settings test
  # subplots_n$x$data[[4]]$showlegend <- FALSE
  # subplots_n$x$data[[7]]$showlegend <- FALSE
  
##------------------------------------------------------------------------------
## Legend - physical                           
##------------------------------------------------------------------------------
  # Logical way to find and turn on poor water quality and WQ thresholds
  # First turn them all off
  for (i in seq(1:length(subplots_p$x$data))) {
    subplots_p$x$data[[i]]$showlegend <- FALSE
  }
  
  # Find the first time the poor water quality point is used- returns the index number
  # ++++++ 20221109 FAILS HERE ++++++++
  # find_pwq <- data.frame(pwq = lapply(seq_along(subplots_p$x$data), 
  #   function(i){
  #     if(subplots_p$x$data[[i]]$name == "orange"){paste0(i)
  #       } else{NA}}) %>% 
  #     unlist()) %>% na.omit() %>% slice(1) %>% as.numeric()
  # 
  # # Find the first time the water quality threshold is used- returns the index number
  # find_wqt <- data.frame(wqt = lapply(seq_along(subplots_p$x$data),
  #   function(i){
  #     if(!is.null(subplots_p$x$data[[i]]$line$dash)){
  #     if(subplots_p$x$data[[i]]$line$dash == "dash"){
  #       paste0(i)
  #       } else{NA}}
  #       else{NA}
  #     } ) %>% unlist()) %>%
  #     na.omit() %>% slice(1) %>% as.numeric()
  
  # Turn on the legends that never change
  subplots_p$x$data[[2]]$showlegend <- TRUE
  subplots_p$x$data[[2]]$name = "Historic range"
  subplots_p$x$data[[5]]$showlegend <- TRUE
  subplots_p$x$data[[5]]$name = "Historic 95% range"
  subplots_p$x$data[[8]]$showlegend <- TRUE
  subplots_p$x$data[[8]]$name = "Historic 50% range"
  subplots_p$x$data[[11]]$showlegend <- TRUE
  subplots_p$x$data[[11]]$name = "Historic median"
  subplots_p$x$data[[12]]$showlegend <- TRUE
  subplots_p$x$data[[12]]$name = "Current value"
  
  # # Turn on the poor water quality and thresholds if they existed
  #+++++++ 20221109 FAILS HERE +++++++
  # if(!is.na(find_pwq)){
  #   subplots_p$x$data[[find_pwq]]$showlegend <- TRUE
  #   subplots_p$x$data[[find_pwq]]$name <- "Poor WQ value"}
  # 
  # if(!is.na(find_wqt)){
  #   subplots_p$x$data[[find_wqt]]$showlegend <- TRUE
  #   subplots_p$x$data[[find_wqt]]$name <- "WQ threshold"}
  
##------------------------------------------------------------------------------
## Legend - nutrients                         
##------------------------------------------------------------------------------
  # Logical way to find and turn on poor water quality and WQ thresholds
  # First turn them all off
  if(params$nutrient == TRUE & !is.null(subplots_n)){
  for (i in seq(1:length(subplots_n$x$data))) {
    subplots_n$x$data[[i]]$showlegend <- FALSE
  }
  
  # Find the first time the historic range is used- returns the index number
  find_hstr <- data.frame(hstr = lapply(seq_along(subplots_n$x$data),
    function(i){
      if(subplots_n$x$data[[i]]$name == "Historic range"){
        paste0(i)
        } else{NA}
      } ) %>% unlist()) %>%
      na.omit() %>% slice(1) %>% as.numeric()
  
  # Find the first time the current value is used- returns the index number
  find_ctv <- data.frame(ctv = lapply(seq_along(subplots_n$x$data),
    function(i){
      # Check that the point has a y value (exists on the plot)
      y_check <- grepl("y",subplots_n$x$data[[i]]$y, fixed=TRUE) %>% unique()
      if(subplots_n$x$data[[i]]$name == "Current value" & y_check==FALSE){paste0(i)
        } else{NA}
      } ) %>% unlist()) %>%
      na.omit() %>% slice(1) %>% as.numeric()
  
  # Find the first time the poor water quality point is used- returns the index number
  find_pwq <- data.frame(pwq = lapply(seq_along(subplots_n$x$data),
    function(i){
      # Check that the point has a y value (exists on the plot)
      y_check <- grepl("y",subplots_n$x$data[[i]]$y, fixed=TRUE) %>% unique()
      if(subplots_n$x$data[[i]]$name == "Poor WQ value" & y_check==FALSE){paste0(i)
        } else{NA}}) %>%
      unlist()) %>% na.omit() %>% slice(1) %>% as.numeric()

  # Find the first time the water quality threshold is used- returns the index number
  find_wqt <- data.frame(wqt = lapply(seq_along(subplots_n$x$data),
    function(i){
      if(subplots_n$x$data[[i]]$name == "WQ threshold"){
        paste0(i)
        } else{NA}
      } ) %>% unlist()) %>%
      na.omit() %>% slice(1) %>% as.numeric()
  
  # If all variables are NA except for historic range, the historic range legend
  # item does not appear in the legend (unclear why). 
  # These solutions don't work.
  # find_ctv <- ifelse((is.na(c(find_ctv, find_pwq, find_wqt))) == TRUE,
  #                    1, NA)
  # find_ctv <- 2
  # find_ctv <- if(is.na(find_ctv) && is.na(find_pwq) && is.na(find_wqt)){1} else {find_ctv}
  

  # Turn on the historic, current, poor WQ, and threshold legends if they exist
  if(!is.na(find_hstr)){
    subplots_n$x$data[[find_hstr]]$showlegend <- TRUE
    }
  
  if(!is.na(find_ctv)){
    subplots_n$x$data[[find_ctv]]$showlegend <- TRUE
    }
  
  if(!is.na(find_pwq)){
    subplots_n$x$data[[find_pwq]]$showlegend <- TRUE
    }

  if(!is.na(find_wqt)){
    subplots_n$x$data[[find_wqt]]$showlegend <- TRUE
    }
  
  # Quick fix to get historic range legend item to appear. Just turning on [[1]]
  # doesn't work. Unclear why - it appears as TRUE in the trace data. 
  subplots_n$x$data[[2]]$showlegend <- TRUE
  } #end of if(params$nutrient == TRUE & !is.null(subplots_n))
##------------------------------------------------------------------------------
## Knit tabs                          
##------------------------------------------------------------------------------
  
  # Create unique chunk labels to use in the tab templates
  site_n <- paste0(site, '_n')
  site_p <- paste0(site, '_p')
  
  # # Create 'not in' operator
  # `%notin%` <- Negate(`%in%`)
  
  # Create tab chunk templates
  # Variables within {{}} are replaced by their value when the report is knit
  
  # if NOT reporting nutrients, use physical parameter template
    if(params$nutrient == FALSE) {
    template <- paste0(
      "### {{site_name}}\n", #create tab with site name
      #create chunk and set chunk options (height, width, echo)
      "```{r {{site_p}}, fig.height=",fig_height_p, ", fig.width=", fig_width,", echo = FALSE}\n",
      "plot_title\n", #title of tab
      "\n",
      "fig_cap_p\n", #caption
      "subplots_p\n", #physical subplots
      "```\n", #close chunk
      "\n"
  )
    
    # if reporting nutrients, create physical and nutrient subtabs 
    } else {template <- paste0(
      "### {{site_name}}{.tabset}\n", #create tab with site name
      "#### Field Measurements\n", #physical subtab
      "```{r {{site_p}}, fig.height=",fig_height_p, ", fig.width=", fig_width,", echo = FALSE}\n",
      "plot_title\n", #title of tab
      "\n",
      "fig_cap_p\n", #caption
      "subplots_p\n", #physical subplots
      "```\n",
      "\n", #this break is necessary for the subtabs to knit correctly
      "#### Lab Chemistry\n", #nutrient subtab
      "```{r {{site_n}}, fig.height=",fig_height_n, ", fig.width=", fig_width,", echo = FALSE}\n",
      "plot_title\n", #title of tab
      "\n",
      "fig_cap_n\n", #caption
      "subplots_n\n", #nutrient subplots
      "```\n",
      "\n"
  )
}
  
  # Expand expressions within {{ }}
  tab <- knitr::knit_expand(text = template)
  
  # Knit results
  cat(knitr::knit(text = unlist(tab), quiet = TRUE))
  
}

```

## About the Sites
```{r leaflet, out.width="100%", message=F}

NPSbasic<-"https://atlas-stg.geoplatform.gov/styles/v1/atlas-user/ck58pyquo009v01p99xebegr9/tiles/256/{z}/{x}/{y}@2x?access_token=pk.eyJ1IjoiYXRsYXMtdXNlciIsImEiOiJjazFmdGx2bjQwMDAwMG5wZmYwbmJwbmE2In0.lWXK2UexpXuyVitesLdwUg"

NPSimagery="https://atlas-stg.geoplatform.gov/styles/v1/atlas-user/ck72fwp2642dv07o7tbqinvz4/tiles/256/{z}/{x}/{y}@2x?access_token=pk.eyJ1IjoiYXRsYXMtdXNlciIsImEiOiJjazFmdGx2bjQwMDAwMG5wZmYwbmJwbmE2In0.lWXK2UexpXuyVitesLdwUg"

NPSslate="https://atlas-stg.geoplatform.gov/styles/v1/atlas-user/ck5cpvc2e0avf01p9zaw4co8o/tiles/256/{z}/{x}/{y}@2x?access_token=pk.eyJ1IjoiYXRsYXMtdXNlciIsImEiOiJjazFmdGx2bjQwMDAwMG5wZmYwbmJwbmE2In0.lWXK2UexpXuyVitesLdwUg"

NPSlight="https://atlas-stg.geoplatform.gov/styles/v1/atlas-user/ck5cpia2u0auf01p9vbugvcpv/tiles/256/{z}/{x}/{y}@2x?access_token=pk.eyJ1IjoiYXRsYXMtdXNlciIsImEiOiJjazFmdGx2bjQwMDAwMG5wZmYwbmJwbmE2In0.lWXK2UexpXuyVitesLdwUg"

bbox <- read.csv("../boundboxes.csv") #lat/long coordinates and zoom level for each park 
site_csv <- read.csv(file = '../SiteInfo.csv') #site names, codes, and descriptions for popup 

# Find center coordinates of park box
long_cent <- mean(c(bbox$LongE[bbox$ParkCode == parkcode], bbox$LongW[bbox$ParkCode == parkcode]))
lat_cent <- mean(c(bbox$LatN[bbox$ParkCode == parkcode], bbox$LatS[bbox$ParkCode == parkcode]))

# Find the first and last date of monitoring for each site
years_active <- getWData(netnwd, parkcode = parkcode, category = params$cat) %>% 
 group_by(Site) %>%
 summarize(start_date = format(min(Date), "%b %Y"),
 last_date = format(max(Date), "%b %Y")) %>%
 ungroup()

# Compile water sites dataframe with codes, names, lat/long coordinates, and site type
water_sites <- data.frame(ParkCode = getSiteInfo(netnwd, parkcode = parkcode, info = "ParkCode"),       
                          SiteCode = getSiteInfo(netnwd, parkcode = parkcode, info = "SiteCode"),
                          SiteName = getSiteInfo(netnwd, parkcode = parkcode, info = "SiteName"), 
                          lat = getSiteInfo(netnwd, parkcode = parkcode, info = "lat"),          
                          long = getSiteInfo(netnwd, parkcode = parkcode, info = "long"),
                          type = getSiteInfo(netnwd, parkcode = parkcode, info = "type")) %>% 
  # Add the active monitoring date range
  left_join(years_active, by = c("SiteCode" = "Site")) %>% 
  # Join descriptions from site info
  left_join(site_csv, by = c("SiteCode", "ParkCode", "SiteName")) %>% 
  # Create html link to the site photo
  mutate(Link = paste0("<a href='https://doimspp.sharepoint.com/sites/NETN_Photo_Viewer/Water_Quality_Site_Photos/", 
                       .$SiteCode, ".jpg' target='_blank'>Site Photo</a>"))

# Legend html generator
# Source: https://stackoverflow.com/questions/47064921/leaflet-legend-for-addawesomemarkers-function-with-icons
# Icon library changed from font-awesome to ion

markerLegendHTML <- function(IconSet) {
    # Container div:
    legendHtml <- "<div style='padding: 10px; padding-bottom: 10px;'>
    <h4 style='padding-top:0; padding-bottom:10px; margin: 0; color:#555'> Legend </h4>" #legend title

    n <- 1
    # Add each icon for ion library icons:
    for (Icon in IconSet) {
        if (Icon[["library"]] == "ion") {
        legendHtml<- paste0(legendHtml,
                            # marker and marker label div
                            "<div style='width: auto; height: 45px; display: flex; align-items: center;'>",
                             # awesome marker div
                             "<div style='position: relative; display: inline-block; width: 35px; height: 45px;' 
                               class='awesome-marker-icon-",Icon[["markerColor"]]," awesome-marker'>",
                               # add icons and set color
                               # class='ion ion-waterdrop icon-white' selects the correct library, icon, and color
                               "<i style='margin-left: 4px; margin-top: 11px' class= 'ion ion-",Icon[["icon"]]," icon-",Icon[["iconColor"]],"'></i>",
                             "</div>", # close awesome marker div
                             # legend label div - use name set in IconSet
                             "<div style='position: relative; display: inline-block; margin-left: 8px;'>", names(IconSet)[n] ,"</div>",
                           "</div>") # close marker/marker label div    
        }
        n <- n + 1
    } 
    paste0(legendHtml, "</div>")
}

# Create list of icons to use in map
IconSet <- awesomeIconList(
  "Stream" = makeAwesomeIcon(icon= 'waterdrop', markerColor = 'blue', iconColor = 'white', library = "ion"),
  "Lake" = makeAwesomeIcon(icon= 'waterdrop', markerColor = 'cadetblue', iconColor = 'white', library = "ion")
)

# Create leaflet map
leaflet() %>%
    # set default view of park
    setView(lng = long_cent,
            lat = lat_cent,
            zoom = bbox$Zoom[bbox$ParkCode == parkcode]) %>%
    # setMaxBounds(lng1 = bbox[bbox$ParkCode == parkcode,]$LongE,
    #              lng2 = bbox[bbox$ParkCode == parkcode,]$LongW,
    #              lat1 = bbox[bbox$ParkCode == parkcode,]$LatN,
    #              lat2 = bbox[bbox$ParkCode == parkcode,]$LatS) %>%
    # add map tiles
    addTiles(group="Map", urlTemplate = NPSbasic, 
             options = providerTileOptions(minZoom = bbox$minZoom[bbox$ParkCode == parkcode])) %>%
    addTiles(group="Imagery", urlTemplate = NPSimagery) %>%
    addTiles(group="Light", urlTemplate = NPSlight) %>%
    addTiles(group="Slate", urlTemplate = NPSslate) %>%
    # add button to control map tiles
    addLayersControl(map = ., baseGroups = c("Map","Imagery","Light", "Slate"),
                     options = layersControlOptions(collapsed=T)) %>%
    # add site markers 
    addAwesomeMarkers(data = water_sites, ~long, ~lat, icon= ~IconSet[type], #style markers based on site type
                      # label on mouseover
                      label=as.character(water_sites$SiteName),
                      # popup on click
                      popup = paste0("<b>", water_sites$SiteName, "</b><br>",
                                     "<b>Type: </b>", water_sites$type, "<br>",
                                     "<b>Sample Period: </b>", water_sites$start_date, "&ndash;", water_sites$last_date, "<br>",
                                     water_sites$Description, "<br>",
                                     water_sites$Link
                                     )
                      ) %>%
    # add legend
    addControl(markerLegendHTML(IconSet = IconSet), position = "bottomleft")

```

```{r About_tabs, child = "About_tabs.Rmd"}

```